<!-- 
 ******************************************************************************
 * Copyright (c) 2012 Oracle
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Konstantin Komissarchik - initial implementation and ongoing maintenance
 ******************************************************************************
-->

<html>

<head>
  <title>Enhancements in Sapphire 0.6</title>
  <link rel="StyleSheet" href="../../style.css" TYPE="text/css"/>
</head>

<body>

<h1>Enhancements in 0.6</h1>

<ol>
  <li><a href="#Modeling">Modeling</a></li>
  <ol type="A">
    <li><a href="#Modeling-VersionsAndVersionConstraints">Versions and Version Constraints</a></li>
    <li><a href="#Modeling-Context">Context</a></li>
    <li><a href="#Modeling-ConversionService">ConversionService</a></li>
    <li><a href="#Modeling-FileName">FileName</a></li>
    <li><a href="#Modeling-MasterConversionService">MasterConversionService</a></li>
    <li><a href="#Modeling-ModelElement">ModelElement</a></li>
    <li><a href="#Modeling-ModelElementList">ModelElementList</a></li>
    <li><a href="#Modeling-ModelElementType">ModelElementType</a></li>
    <li><a href="#Modeling-PreferDefaultValue">@PreferDefaultValue</a></li>
    <li><a href="#Modeling-Service">Service</a></li>
  </ol>
  <li><a href="#ExpressionLanguage">Expression Language</a></li>
  <ol type="A">
    <li><a href="#ExpressionLanguage-EnabledFunction">Enabled Function</a></li>
    <li><a href="#ExpressionLanguage-UpperCaseFunction">UpperCase Function</a></li>
    <li><a href="#ExpressionLanguage-LowerCaseFunction">LowerCase Function</a></li>
    <li><a href="#ExpressionLanguage-UseInPageHeaderText">Use in Page Header Text</a></li>
    <li><a href="#ExpressionLanguage-UseInOutlineHeaderText">Use in Outline Header Text</a></li>
    <li><a href="#ExpressionLanguage-UseInConditional">Use in Conditional</a></li>
    <li><a href="#ExpressionLanguage-UseInSectionVisibilityConstraint">Use in Section Visibility Constraint</a></li>
    <li><a href="#ExpressionLanguage-UseInNodeVisibilityConstraint">Use in Node Visibility Constraint</a></li>
    <li><a href="#ExpressionLanguage-UseInNodeFactoryVisibilityConstraint">Use in Node Factory Visibility Constraint</a></li>
    <li><a href="#ExpressionLanguage-UseInPropertyEditorVisibilityConstraint">Use in Property Editor Visibility Constraint</a></li>
  </ol>
  <li><a href="#Miscellaneous">Miscellaneous</a></li>
  <ol type="A">
    <li><a href="#Miscellaneous-ConvertToFromNamespace">XmlUtil.convertToNamespaceFrom and convertFromNamespaceForm</a></li>
    <li><a href="#Miscellaneous-CollectionFactoriesEnhancements">Enhancements to Collection Factories</a></li>
    <li><a href="#Miscellaneous-JdtUtil">JdtUtil</a></li>
    <li><a href="#Miscellaneous-MasterDetailsContentNode">MasterDetailsContentNode</a></li>
    <li><a href="#Miscellaneous-SapphirePart">SapphirePart</a></li>
    <li><a href="#Miscellaneous-Status">Status</a></li>
    <li><a href="#Miscellaneous-Value">Value</a></li>
    <li><a href="#Miscellaneous-OverwriteExistingFile">Overwrite Existing File</a></li>
  </ol>
</ol>


<h2><a name="Modeling"><a name="Modeling-VersionsAndVersionConstraints">Versions and Version Constraints</a></a></h2>

<p>In many complex Sapphire models, it is useful to be able to constrain functionality based on a version. To simplify these scenarios,
Sapphire now has native constructs for dealing with versions and version constraints.</p>

<p><b>Version</b> - Represents a version as a sequence of long integers. In string format, it is represented as a dot-separated
list of numeric segments, such as "1.2.3" or "5.7.3.2012070310003".</p>

<p><b>VersionConstraint</b> - A boolean expression that can check versions for applicability. In string 
format, it is represented as a comma-separated list of specific versions, closed 
ranges (expressed using "[1.2.3-4.5)" syntax and open ranges (expressed using "[1.2.3" or "4.5)" 
syntax). The square brackets indicate that the range includes the specified version. The parenthesis 
indicate that the range goes up to, but does not actually include the specified version.</p>

<p><b>Sapphire.version()</b> - Determines the version of Sapphire.</p>

<p>Both Version and VersionConstraint classes can be used as a type of a value property.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">// *** Version ***</font>
    
@Type( base = Version.class )

<font color="#888888">ValueProperty PROP_VERSION = new ValueProperty( TYPE, "Version" );
    
Value&lt;</font>Version<font color="#888888">> getVersion();
void setVersion( String value );
void setVersion(</font> Version <font color="#888888">value );
    
// *** VersionConstraint ***</font>
    
@Type( base = VersionConstraint.class )

<font color="#888888">ValueProperty PROP_VERSION_CONSTRAINT = new ValueProperty( TYPE, "VersionConstraint" );
    
Value&lt;</font>VersionConstraint<font color="#888888">> getVersionConstraint();
void setVersionConstraint( String value );
void setVersionConstraint(</font> VersionConstraint <font color="#888888">value );</font></code></pre>

<p>Further, version constraints can be evaluated in an expression via a pair of new functions. The VersionMatches function takes a version
as the first parameter, a version constraint as a second parameter and returns a boolean. The SapphireVersionMatches function takes a version
constraint as the sole parameter, evaluates it against Sapphire version and returns a boolean.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, the VersionMatches function is used to control property enablement.</p>

<pre class="source-code"><code><font color="#888888">// *** Provider ***
    
@Label( standard = "provider" )</font>
@Enablement( expr = "${ VersionMatches( Root().Version, '[1.1' ) }" )
<font color="#888888">@XmlBinding( path = "provider" )

ValueProperty PROP_PROVIDER = new ValueProperty( TYPE, "Provider" );

Value&lt;String> getProvider();
void setProvider( String value );</font></code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, the VersionMatches function is used in sdef to control visibility of a properties
view page.</p>

<pre class="source-code"><code><font color="#888888">&lt;properties-view>
    &lt;page>
        &lt;label>provider&lt;/label></font>
        &lt;visible-when>${ VersionMatches( Root().Version, '[1.1' ) }&lt;/visible-when>
        <font color="#888888">&lt;content>
            &lt;property-editor>Provider&lt;/property-editor>
            &lt;property-editor>
                &lt;property>Copyright&lt;/property>
                &lt;scale-vertically>true&lt;/scale-vertically>
            &lt;/property-editor>
        &lt;/content>
    &lt;/page>
&lt;/properties-view></font></code></pre>


<h2><a name="Modeling-Context">Context</a></h2>

<p>The existing ClassLocator and ResourceLocator abstractions have been combined into a single abstraction.
This abstraction enables Sapphire to find classes and other resources typically loaded from
a class loader even if Sapphire is used in a context such as OSGi where a ClassLoader instance may not always
be exposed.</p>

<pre class="source-code"><code>Context
{
     static Context adapt( ClassLoader loader )
     static Context adapt( Class&lt;?> cl )
     
     abstract &lt;T> Class&lt;T> findClass( String name )
     abstract URL findResource( String name )
     abstract List&lt;URL> findResources( String name )
}
 
BundleBasedContext extends Context
{
     static Context adapt( Bundle bundle )
}</code></pre>

<p>In addition to merging of the locators, this enhancement includes two new features:</p>

<ol>

  <li>The findResources() method, which is used for locating all resources with the same name.</li> 

  <li>When Context is constructed based on a class instead of a class loader, the implementation is 
  capable of resolving classes and resources using a simple name relative to the package of context class.</li>
  
</ol>


<a name="Modeling-ConversionService"><h2>ConversionService</h2></a>

<p>The ConversionService converts an object to the specified type. One common application is to convert
an input (such as a file) to a resource when instantiating the model.</p>

<table>
  <tr>
    <th>Sapphire.ConversionService.IFileToWorkspaceFileResourceStore</th>
  </tr>
  <tr>
    <td>Capable of converting an IFile to a WorkspaceFileResourceStore or a ByteArrayResourceStore.</td>
  </tr>
  <tr>
    <td style="border-width: 0px; height: 20px"></td>
  </tr>
  <tr>
    <th>Sapphire.ConversionService.ByteArrayResourceStoreToXmlResource</th>
  </tr>
  <tr>
    <td>Capable of converting a ByteArrayResourceStore to an XmlResource or a Resource. Conversion is only 
    performed if resource store corresponds   to a file with "xml" extension or if the context element type 
    has XML binding annotations.</td>
  </tr>
</table>

<p>A ConversionService can delegate to other conversion services to create a conversion chain. In fact,
a common conversion of IFile to XmlResource is a chain of two ConversionService implementations.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In the purchase order sample, a custom ConversionService is used because the 
default file extension for purchase order files is "po" rather than "xml" and PurchaseOrder element does not
have XML binding annotations. The combination of these two factors prevent the framework-provided ConversionService
implementations from engaging.</p>

<pre class="source-code"><code>@Service( impl = PurchaseOrderResourceConversionService.class )

<font color="#888888">public interface PurchaseOrder extends IModelElement
{
    ...
}</font></code></pre>

<pre class="source-code"><code>public class PurchaseOrderResourceConversionService extends ConversionService
{
    @Override
    public &lt;T> T convert( Object object, Class&lt;T> type )
    {
        if( type == XmlResource.class || type == Resource.class )
        {
            final ByteArrayResourceStore store = service( MasterConversionService.class ).convert( object, ByteArrayResourceStore.class );
            
            if( store != null )
            {
                return type.cast( new RootXmlResource( new XmlResourceStore( store ) ) );
            }
        }
        
        return null;
    }
}</code></pre>

<p style="margin-left: 20px;">Note the use of chaining as part of the presented ConversionService implementation. The 
input could be any number of things, but as long as another ConversionService implementation knows how to convert it 
to a ByteArrayResourceStore, this implementation will take the conversion the rest of the way to a Resource.</p> 


<h2><a name="Modeling-FileName">FileName</a></h2>

<p>When implementing operations that create files, a common need is to gather the name of a file 
from the user. The file name must be validated to be compatible with user's platform and certain 
normalization should be performed to simplify file name input.</p>

<p>Sapphire now provides FileName class and associated services.</p>

<ol>

  <li><b>ValidationService</b> – Flags invalid file names as errors.</li>

  <li><b>ValueSerializationService</b> – Only creates FileName objects that are valid for the current platform.</li>

  <li><b>ValueNormalizationService</b></li>
  
  <ol type="A">

    <li>Leading whitespace is removed.</li>
   
    <li>Trailing whitespace and dots are removed.</li>
   
    <li>Extension is added if the file name does not have one already and if the property has 
    a FileExtensionsService (usually via @FileExtensions annotation).</li>
    
  </ol>
  
</ol>


<a name="Modeling-MasterConversionService"><h2>MasterConversionService</h2></a>

<p>The MasterConversionService converts an object to the specified type by delegating to available ConversionService 
implementations. If object is null or is already of desired type, the object is returned unchanged.</p> 

<p>An implementation of this service is provided with Sapphire. This service is not intended to
be implemented by adopters. See <a href="#Modeling-ConversionService">ConversionService</a> instead.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, an IFile is converted to a Resource as part of instantiating the model.
Note how this code is not aware of the details of the conversion or what type of a resource is created.</p>

 <pre class="source-code"><code><font color="#888888">IFile file = project.getFile( "contacts.xml" )</font>
Resource resource = ContactsDatabase.TYPE.service( MasterConversionService.class ).convert( file, Resource.class );
<font color="#888888">ContactsDatabase model = ContactsDatabase.TYPE.instantiate( resource );</font></code></pre>


<h2><a name="Modeling-ModelElement">ModelElement</a></h2>

<p>The existing ModelElement.initialize() method has been enhanced to be consistent with fluent interface principles by returning 
the element instead of void. This facilitates chaining.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two snippets are equivalent.</p>

<pre class="source-code"><code>Operation op = Operation.TYPE.instantiate( resource );
op.initialize();</font></code></pre>

<pre class="source-code"><code>Operation op = Operation.TYPE.instantiate( resource ).initialize();</font></code></pre>

<p>A new variant of attach() and detach() methods has been added to make it a bit less verbose to listen for changes
to a particular property.</p>

<pre class="source-code"><code><font color="#888888">ModelElement
{</font>
    <font color="#888888">boolean attach( Listener listener )
    void attach( Listener listener, String path )
    void attach( Listener listener, ModelPath path )</font>
    void attach( Listener listener, ModelProperty property )
    
    <font color="#888888">boolean detach( Listener listener )
    void detach( Listener listener, String path )
    void detach( Listener listener, ModelPath path )</font>
    void detach( Listener listener, ModelProperty property )
<font color="#888888">}</font></code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two snippets are equivalent.</p>

<pre class="source-code"><code>op.attach( listener, Operation.PROP_FILE_NAME.getName() );</code></pre>

<pre class="source-code"><code>op.attach( listener, Operation.PROP_FILE_NAME );</code></pre>

<p>Several method have been enhanced with an overloaded variant that accepts a string property name in place
of a ModelProperty object. This reduces verbosity in situations where code does not already have a ModelProperty
instance handy.</p> 

<pre class="source-code"><code><font color="#888888">ModelElement
{
    &lt;S extends Service> S service( ModelProperty property, Class&lt;S> serviceType )</font>
    &lt;S extends Service> S service( String property, Class&lt;S> serviceType )
    
    <font color="#888888">&lt;S extends Service> List&lt;S> services( ModelProperty property, Class&lt;S> serviceType )</font>
    &lt;S extends Service> List&lt;S> services( String property, Class&lt;S> serviceType )
    
    <font color="#888888">boolean enabled( ModelProperty property )</font>
    boolean enabled( String property )
    
    <font color="#888888">Status validation( ModelProperty property )</font>
    Status validation( String property )
<font color="#888888">}</font></code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two snippets are equivalent.</p>

<pre class="source-code"><code>Status validation = op.validation( op.property( "FileName" ) );</code></pre>

<pre class="source-code"><code>Status validation = op.validation( "FileName" );</code></pre>


<h2><a name="Modeling-ModelElementList">ModelElementList</a></h2>

<p>The new ModelElementList.enabled() method provides a simpler way to check list property's enablement
directly through the property accessor.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two statements are equivalent.</p>

<pre class="source-code"><code>container.getEntities().enabled()</font></code></pre>

<pre class="source-code"><code>container.enabled( Container.PROP_ENTITIES )</code></pre>


<h2><a name="Modeling-ModelElementType">ModelElementType</a></h2>

<p>A new variant of instantiate method provides a way to create a model instance from an arbitrary input
without knowing which resource needs to be created. The resource creation is handled by delegating
to ConversionService implementations.</p>

<pre class="source-code"><code><font color="#888888">ModelElementType
{
    &lt;T extends IModelElement> T instantiate()
    &lt;T extends IModelElement> T instantiate( Resource resource )</font>
    &lt;T extends IModelElement> T instantiate( Object input )
<font color="#888888">}</font></code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following three snippets are equivalent.</p>

<pre class="source-code"><code>Resource resource = new RootXmlResource( new XmlResourceStore( new WorkspaceFileResourceStore( file ) ) );
PurchaseOrder po = PuchaseOrder.TYPE.instantiate( resource );</code></pre>

<pre class="source-code"><code>Resource resource = PurchaseOrder.TYPE.service( MasterConversionService.class ).convert( file, Resource.class );
PurchaseOrder po = PuchaseOrder.TYPE.instantiate( resource );</code></pre>

<pre class="source-code"><code>PurchaseOrder po = PuchaseOrder.TYPE.instantiate( file );</code></pre>


<h2><a name="Modeling-PreferDefaultValue">@PreferDefaultValue</a></h2>

<p>In certain cases, deviations from property's default value are allowed, but not recommended.</p>

<p>Consider a file creation wizard where the file should have a certain name to function properly. 
This is common for configuration files. For flexibility and consistency, the wizard should allow 
a different file name to be used if the user so desires, but it should warn the user that they 
are deviating from the file name recommendation.</p>

<p>The new @PreferDefaultValue annotation is used to specify the above semantics. Utilizing this 
annotation produces a warning and a fact statement.</p>

<p>Warning: <i>[property] should be [default-value].</i><br/>
Fact: <i>Recommended value is [default-value].</i></p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@DefaultValue( text = "sapphire-extension.xml" )</font>
@PreferDefaultValue
 
<font color="#888888">ValueProperty PROP_FILE_NAME = new ValueProperty( TYPE, CreateWorkspaceFileOp.PROP_FILE_NAME );</font></code></pre>

<p style="margin-left: 20px;"><img src="images/PreferDefaultValue.png"/></p>


<h2><a name="Modeling-Service">Service</a></h2>

<p>In the past, when a service implementation needed to leverage another service from the same context, 
service context needed to be referenced explicitly. This led to unnecessary verbosity, so a pair of
convenience methods have been added that delegate to the current context.</p>

<pre class="source-code"><code><font color="#888888">Service
{</font>
    protected final &lt;S extends Service> S service( Class&lt;S> serviceType )
    protected final &lt;S extends Service> List&lt;S> services( Class&lt;S> serviceType )
<font color="#888888">}</font></code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two snippets are equivalent within Service implementation.</p>

<pre class="source-code"><code>context().service( ExampleService.class )</code></pre>

<pre class="source-code"><code>service( ExampleService.class )</code></pre>


<h2><a name="ExpressionLanguage"><a name="ExpressionLanguage-EnabledFunction">Enabled Function</a></a></h2>

<p>Determines if a property is enabled. Can be used either with two arguments (element and property name) or with
a single property name argument. In the single argument form, the context element is used.</p>

<p style="margin-left: 20px;"><b>Examples</b></p>

<p style="margin-left: 20px;">In these examples, the context element is Employee which has Assistant and Manager
properties. The first example asks if Assistant property is enabled for this employee. The second example asks
if Assistant property is enable for this employee's manager.</p>

<pre class="source-code"><code>${ Enabled( 'Assistant' ) }
${ Enabled( Manager, 'Assistant' ) }</code></pre>


<h2><a name="ExpressionLanguage-UpperCaseFunction">UpperCase Function</a></h2>

<p>Converts a string to upper case.</p>

<p style="margin-left: 20px;"><b>Examples</b></p>

<pre class="source-code"><code>${ UpperCase( Name ) }
${ Name.UpperCase() }</code></pre>


<h2><a name="ExpressionLanguage-LowerCaseFunction">LowerCase Function</a></h2>

<p>Converts a string to lower case.</p>

<p style="margin-left: 20px;"><b>Examples</b></p>

<pre class="source-code"><code>${ LowerCase( Name ) }
${ Name.LowerCase() }</code></pre>


<h2><a name="ExpressionLanguage-UseInPageHeaderText">Use EL in Page Header Text</a></h2>

<p>Use expression language when specifying editor page header text.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;editor-page>
    &lt;page-header-text></font>contacts (${ Contacts.Size })<font color="#888888">&lt;/page-header-text>
&lt;/editor-page></font></code></pre>


<h2><a name="ExpressionLanguage-UseInOutlineHeaderText">Use EL in Outline Header Text</a></h2>

<p>Use expression language when specifying master details outline header text.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;editor-page>
    &lt;outline-header-text></font>outline (${ Contacts.Size })<font color="#888888">&lt;/outline-header-text>
&lt;/editor-page></font></code></pre>


<h2><a name="ExpressionLanguage-UseInConditional">Use EL in Conditional</a></h2>

<p>Use expression language when specifying a conditional (if-then-else).</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;if>
    &lt;condition></font>${ VersionMatches( Root().Version, "[1.1" ) }<font color="#888888">&lt;/condition>
    &lt;then>
        ...
    &lt;/then>
    &lt;else>
        ...
    &lt;/else>
&lt;/if></font></code></pre>


<h2><a name="ExpressionLanguage-UseInSectionVisibilityConstraint">Use EL in Section Visibility Constraint</a></h2>

<p>Use expression language when specifying visibility of a section.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;section>
    &lt;visible-when></font>${ VersionMatches( Root().Version, "[1.1" ) }<font color="#888888">&lt;/condition>
    &lt;content>
        ...
    &lt;/content>
&lt;/section></font></code></pre>


<h2><a name="ExpressionLanguage-UseInNodeVisibilityConstraint">Use EL in Node Visibility Constraint</a></h2>

<p>Use expression language when specifying visibility of a master-details content node.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;node>
    &lt;visible-when></font>${ VersionMatches( Root().Version, "[1.1" ) }<font color="#888888">&lt;/condition>
    &lt;section>
        ...
    &lt;/section>
&lt;/node></font></code></pre>


<h2><a name="ExpressionLanguage-UseInNodeFactoryVisibilityConstraint">Use EL in Node Factory Visibility Constraint</a></h2>

<p>Use expression language when specifying visibility of a master-details content node factory.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;node-factory>
    &lt;property>Entities&lt;/property>
    &lt;visible-when></font>${ VersionMatches( Root().Version, "[1.1" ) }<font color="#888888">&lt;/condition>
    &lt;case>
        ...
    &lt;case>
&lt;/node-factory></font></code></pre>


<h2><a name="ExpressionLanguage-UseInPropertyEditorVisibilityConstraint">Use EL in Property Editor Visibility Constraint</a></h2>

<p>Use expression language when specifying visibility of a property editor.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;property-editor>
    &lt;property>Description&lt;/property>
    &lt;visible-when></font>${ VersionMatches( Root().Version, "[1.1" ) }<font color="#888888">&lt;/condition>
&lt;/property-editor></font></code></pre>


<h2><a name="Miscellaneous"><a name="Miscellaneous-ConvertToFromNamespace">XmlUtil.convertToNamespaceFrom and convertFromNamespaceForm</a></a></h2>

<p>Two static utility methods have been added to XmlUtil to make it easier to convert documents to and from namespace-qualified form.</p>

<pre class="source-code"><code>public static void convertToNamespaceForm( Document document, String namespace )
public static void convertToNamespaceForm( Document document, String namespace, String schemaLocation )
public static void convertFromNamespaceForm( Document document )</code></pre>


<h2><a name="Miscellaneous-CollectionFactoriesEnhancements">Enhancements to Collection Factories</a></h2>

<p>The collection factories have been enhanced with new methods to support broader range of use cases and a 
brand new SortedSetFactory.</p>

<pre class="source-code"><code><font color="#888888">ListFactory
{</font>
    static List&lt;E> empty()
    static List&lt;E> singleton( E element )
    static List&lt;E> unmodifiable( E... elements )
    static List&lt;E> unmodifiable( Collection&lt;E> elements )
    
    <font color="#888888">static ListFactory&lt;E> start()

    ListFactory&lt;E> add( E element )
    ListFactory&lt;E> add( E... element )
    ListFactory&lt;E> add( Collection&lt;E> element )</font>
    E remove( int index )
    E get( int index )
    boolean contains( E element )
    int size()
    
    <font color="#888888">ListFactory&lt;E> result()
}
 
SetFactory
{</font>
    static Set&lt;E> empty()
    static Set&lt;E> singleton( E element )
    static Set&lt;E> unmodifiable( E... elements )
    static Set&lt;E> unmodifiable( Collection&lt;E> elements )
    
    <font color="#888888">static SetFactory&lt;E> start()

    SetFactory&lt;E> add( E element )
    SetFactory&lt;E> add( E... element )
    SetFactory&lt;E> add( Collection&lt;E> element )</font>
    boolean remove( E element )
    boolean contains( E element )
    int size()
    
    <font color="#888888">SortedSet&lt;E> result()
}</font>
 
SortedSetFactory
{
    static SortedSet&lt;E> empty()
    static SortedSet&lt;E> singleton( E element )
    static SortedSet&lt;E> unmodifiable( E... elements )
    static SortedSet&lt;E> unmodifiable( Collection&lt;E> elements )
    
    static SortedSetFactory&lt;E> start()
    static SortedSetFactory&lt;E> start( Comparator&lt;E> comparator )
    
    SortedSetFactory&lt;E> add( E element )
    SortedSetFactory&lt;E> add( E... element )
    SortedSetFactory&lt;E> add( Collection&lt;E> element )
    boolean remove( E element )
    E first()
    E last()
    boolean contains( E element )
    int size()
    
    SortedSet&lt;E> result()
}
 
<font color="#888888">MapFactory
{</font>
    static Map&lt;K,V> empty()
    static Map&lt;K,V> singleton( K key, V value )
    static Map&lt;K,V> unmodifiable( Map&lt;K,V> map )
    
    <font color="#888888">static MapFactory&lt;K,V> start()

    MapFactory&lt;K,V> add( K key, V value )
    MapFactory&lt;K,V> add( Map&lt;K,V> map )</font>
    V remove( K key )
    V get( K key )
    boolean contains( K key )
    boolean containsKey( K key )
    boolean containsValue( V value )
    int size()
    
    <font color="#888888">Map&lt;K,V> result()
}</font></code></pre>


<h2><a name="Miscellaneous-JdtUtil">JdtUtil</a></h2>

<p>Various scenarios in both Sapphire and common usage of Sapphire require locating Java source folders. 
Sapphire JDT integration now includes a set of utility functions to make this easier.</p>

<pre class="source-code"><code>JdtUtil
{
    <font color="#008444">// Finds the nearest Java source folder for the specified resource.
    // The nearest is defined as either the source folder containing 
    // the specified resource or the first non-derived source folder 
    // of the containing project.</font>

    static IContainer findSourceFolder( IResource resource )

    <font color="#008444">// Finds all source folders for a project, which is specified either
    // directly or indirectly via a contained resource.</font>

    static List&lt;IContainer> findSourceFolders( IResource resource )
    static List&lt;IContainer> findSourceFolders( IProject project )
    static List&lt;IContainer> findSourceFolders( IJavaProject project )
}</code></pre>


<h2><a name="Miscellaneous-MasterDetailsContentNode">MasterDetailsContentNode</a></h2>

<p>The method for accessing child nodes has been enhanced. The MasterDetailsContentNode.nodes() method now
returns a customized list object that provides additional operations specific to list of nodes. For instance,
there is a method to filter list of nodes to contain only visible nodes.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following produces all nodes whether or not they are visible.</p>

<pre class="source-code"><code>root.nodes()</font></code></pre>

<p style="margin-left: 20px;">A slight variation on the above statement produces only the visible nodes.</p>

<pre class="source-code"><code>root.nodes().visible()</font></code></pre>

<p>The new NodeListEvent provides notification when the list of child nodes changes. Note that this event
does not fire when child node visibility changes. See VisibilityChangedEvent for that functionality.</p>

<pre class="source-code"><code>node.attach
(
    new FilteredListener&lt;NodeListEvent>()
    {
        @Override
        protected void handleTypedEvent( NodeListEvent event )
        {
            ...
        }
    }
)</code></pre>


<h2><a name="Miscellaneous-SapphirePart">SapphirePart</a></h2>

<p>Check part's visibility using SapphirePart.visible() method. To get notified of changes to part's visibility,
listen for VisibilityChangedEvent.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>boolean visible = editor.visible()
 
editor.attach
(
    new FilteredListener&lt;VisibilityChangedEvent>()
    {
        @Override
        protected void handleTypedEvent( VisibilityChangedEvent event )
        {
            ...
        }
    }
)</code></pre>


<h2><a name="Miscellaneous-Status">Status</a></h2>

<p>The new Status.contains() method provides a simpler way to check if property validation has a problem
of certain type. This can be useful when implementing automated validation problem fixes.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>if( op.getFileName().validation().contains( "Sapphire.Workspace.CreateFileOp.FileExists" ) )
{
    ...
}</code></pre>


<h2><a name="Miscellaneous-Value">Value</a></h2>

<p>The new Value.enabled() method provides a simpler way to check value property's enablement
directly through the property accessor.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The following two statements are equivalent.</p>

<pre class="source-code"><code>entity.getName().enabled()</code></pre>

<pre class="source-code"><code>entity.enabled( Entity.PROP_NAME )</code></pre>


<h2><a name="Miscellaneous-OverwriteExistingFile">Overwrite Existing File</a></h2>

<p>The reusable form for creating workspace files has been enhanced with an automated problem resolution to overwrite
an existing file. This makes it slightly easier for user to go from problem to resolution since both are presented
in the same popup.</p>

<p style="margin-left: 20px;"><img src="images/OverwriteExistingFile.png"/></p>


<div class="copyright">Copyright (c) 2012 Oracle<br/>
Content made available under the terms of <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public License</a>.</div>


</body>

</html>